module sphexp
  use sph_leg_pol
  use data_types
  use quads
  use dataread
  !use tblinf
contains
subroutine run_int_test
  LOGICAL :: loop
  REAL(KIND=8),dimension(:,:,:,:),ALLOCATABLE :: data(:,:,:,:)
  CHARACTER(LEN=90) :: filename,filein
  INTEGER(hsize_t) ::ij,s,ik,sts
  TYPE(fruit) :: modlya,modlyi
  REAL(KIND=8), dimension(6) :: am1,am2
 
  real :: r
  integer :: i,j,reason,NstationFiles
  character(LEN=40), dimension(:), allocatable :: stationFileNames
  ! get the files
  !open(31,FILE='fileContents.txt',action="write")
  !close(31)
  !call system('ls ./files > fileContents.txt')
  !open(31,FILE='./fileContents.txt',action="read")
  !how many
  !i = 0
  !do
  ! read(31,FMT='(a)',iostat=reason) r
  ! if (reason/=0) EXIT
  ! i = i+1
  !end do
  !NstationFiles = i
  !write(*,'(a,I0)') "Number of station files: " , NstationFiles
  !allocate(stationFileNames(NstationFiles))
  !rewind(31)
  !do i = 1,NstationFiles
  !   read(31,'(a)') stationFileNames(i)
  !enddo
  !close(31)
  2000 format(7(1E20.10))

   
   ik =1
   !ALLOCATE(cutm, STAT = sts)
   CALL getarg(1, filein)
   filename = 'sph_an'//trim(filein)//'.dat' 	
   open(332,FILE=trim(filename),action="write",position='append')
   filename = 'gw_rot'//trim(filein)//'.dat'
   open(333,FILE=trim(filename),action="write",position='append')

  ! do i = 1,1!NstationFiles
   
   filename = './'//trim(filein)//'/'//trim(filein) 
   ij = 0
   loop = .TRUE.
   write(*,*) filename
   do while(loop)
      CALL setdata(filename,ij,modlya,s,2)
      CALL setdata(filename,ij,modlyi,s,1)
      ! CALL setdata(filename,ij,modlyi,s,0)
      ij = ij+1
      !if( ij .EQ. s) then
         loop = .FALSE. 
      !endif
      CALL integral_test(modlya,am1,am2,modlyi)      
      write(332,2000) modlya%time-0.24892d0,am2
      write(333,2000) modlya%time-0.24892d0,am1
      !loop = .FALSE. 
   enddo
   !end do
   close(332)
   close(333)
 end subroutine run_int_test


  subroutine integral_test(modlya,amp1,amp2,modlyi)
    USE sph_leg_pol
    implicit none
    TYPE(fruit), INTENT(IN) :: modlya
    TYPE(fruit),OPTIONAL, INTENT(IN) :: modlyi 
    TYPE(fruit) :: yat,yit
    REAL(KIND=8), DIMENSION(6), INTENT(OUT) :: amp1,amp2 
    REAL(KIND=8) :: pc_gc
    parameter(pc_gc = 6.67259d-08)
    REAL(KIND=8) :: pc_pi
    parameter(pc_pi = dacos(-1d0))
    REAL(KIND=8) :: pc_cl
    parameter(pc_cl = 2.99792458d+10)
    REAL(KIND=8) :: geofac
    parameter(geofac = 1.d0/3.d0)
  
    REAL(KIND=8) :: x,y,z,rsin,dmas,ph,th,ph1,th1,sph1,sph2,c2,gc2vf
    INTEGER :: nx,ny,nz,j,k,ast,l,m,lm,i,js,jks
    REAL(KIND=8) :: qxx,qyy,qzz,qxy,qxz,qyz
    REAL(KIND=8) :: axx,ayy,azz,axy,axz,ayz

    REAL(KIND=8), dimension(:),ALLOCATABLE :: dph(:),dth(:),dr(:),cth,sth,cph,sph
    REAL(KIND=8) :: corr_sph,corr_cth,corr_sth
    REAL(KIND=8), dimension(:,:),ALLOCATABLE :: vxcofs,vycofs,vzcofs,dencofs
    REAL(KIND=8), dimension(:,:,:),ALLOCATABLE,target :: ud(:,:,:)
    REAL(KIND=8), dimension(:,:,:),ALLOCATABLE :: dphidr(:,:,:) 
    REAL(KIND=8), DIMENSION(6) :: amplya,amplyi 
    gc2vf = pc_gc/pc_cl**2d0
    c2 = pc_cl**2d0

    nx=size(modlya%den(:,1,1))
    ny=size(modlya%den(1,:,1))
    nz=size(modlya%den(1,1,:))

    !write(*,*) nx,ny,nz
    ALLOCATE (dth(ny), STAT = ast)
    ALLOCATE (dph(nz), STAT = ast)
    dth = dcos(modlya%yzl(:))-dcos(modlya%yzr(:))
    dph = modlya%zzr(:)-modlya%zzl(:)

    corr_cth = 0.99995140318460529d0! dsqrt(2d0/3d0/corr_cth)
    corr_sth = 1.000024301064834d0!dsqrt(4d0/3d0/corr_sth)
    corr_sph = 0.99999978633434816d0 !Ewalds factor

    ALLOCATE (sph(nz), STAT = ast)
    ALLOCATE (cph(nz), STAT = ast)

    ALLOCATE (cth(ny), STAT = ast)
    ALLOCATE (sth(ny), STAT = ast)

    do j = 1,ny
       cth(j) = dcos(modlya%yzn(j))*corr_cth
       sth(j) = dsin(modlya%yzn(j))*corr_sth
    end do
    do k =1,nz
       cph(k) = dcos(modlya%zzn(k))
       sph(k) = dsin(modlya%zzn(k))!*corr_sph
    end do
    dr = modlya%xzr(:)**3-modlya%xzl(:)**3
    ALLOCATE(vxcofs(0:lmax,-lmax:lmax), STAT = ast)
    vxcofs = 0.0d0
    ALLOCATE(vycofs(0:lmax,-lmax:lmax), STAT = ast)
    vycofs = 0.0d0
    ALLOCATE(vzcofs(0:lmax,-lmax:lmax), STAT = ast)
    vzcofs = 0.0d0
    ALLOCATE(dencofs(0:lmax,-lmax:lmax), STAT = ast)
    dencofs = 0.0d0

    ALLOCATE (dphidr(nx,ny,nz), STAT = ast)
    do i=1,nx-1
       dphidr(i,:,:) = (modlya%gpo(i+1,1:ny,:)-modlya%gpo(i,1:ny,:))/(modlya%xzr(i)-modlya%xzl(i))
    enddo
    dphidr(nx,:,:) = (modlya%gpo(nx,1:ny,:)-modlya%gpo(nx-1,1:ny,:))/(modlya%xzr(nx)-modlya%xzl(nx))
    yat = modlya
    yit = modlyi
    amp2 = 0.0d0
    axx = 0.0d0; ayy = 0.0d0; azz = 0.0d0;
    axy = 0.0d0; axz = 0.0d0; ayz = 0.0d0;
    qxx = 0.0d0; qyy = 0.0d0; qzz = 0.0d0;
    qxy = 0.0d0; qxz = 0.0d0; qyz = 0.0d0;
  
    !$OMP PARALLEL DO &
    !$OMP & PRIVATE(i,l,m,k,j,qxx,qyy,qzz,qxy,qxz,qyz,z,x,y,th,ph,th1,ph1,dmas,rsin,sph1,sph2) &
    !$OMP & SHARED(modlya,modlyi,dphidr, dr,cph,sph,dth,dph) &
    !$OMP & REDUCTION(+:axx,ayy,azz,axy,axz,ayz,vxcofs,vycofs,vzcofs,dencofs)
    do i = 100,100!nx
       vxcofs = 0.0d0; vzcofs = 0.0d0; vzcofs = 0.0d0
       dencofs = 0.0d0
       qxx = 0.0d0; qyy = 0.0d0; qzz = 0.0d0;
       qxy = 0.0d0; qxz = 0.0d0; qyz = 0.0d0;
       do k=1,nz
          do j=1,ny
             rsin = sth(j)
             z = cth(j)
             x = rsin * cph(k)
             y = rsin * sph(k)
             th = acos(z)
             ph = atan2(y,x)
             th1 = acos(y)
             ph1 = atan2(z,-x)
             dmas = dph(k)*dth(j)*modlya%yyw(j,k)
             do l = 0,lmax
                do m = -l,l
                   sph1 = (spharm_r(l,m,th,ph))*(-1.d0**dble(abs(m)))/(sqrt(4.d0*pc_pi*dble(2*l+1)))
                   sph2 = (spharm_r(l,m,th1,ph1))*(-1.d0**dble(abs(m)))/(sqrt(4.d0*pc_pi*dble(2*l+1)))
                   vxcofs(l,m) = vxcofs(l,m) + (modlya%vex(i,j,k)*sph1 + modlyi%vex(i,j,k)*sph2)*dmas
                   vycofs(l,m) = vycofs(l,m) + (modlya%vey(i,j,k)*sph1 + modlyi%vey(i,j,k)*sph2)*dmas
                   vzcofs(l,m) = vzcofs(l,m) + (modlya%vez(i,j,k)*sph1 + modlyi%vez(i,j,k)*sph2)*dmas
                   dencofs(l,m) = dencofs(l,m) + (modlya%den(i,j,k)*sph1 + modlyi%den(i,j,k)*sph2)*dmas
                enddo
             enddo
          end do
       end do
       do k=1,nz
          do j=1,ny
             rsin = sth(j)
             z = cth(j)
             x = rsin * cph(k)
             y = rsin * sph(k)
             th = acos(z)
             ph = atan2(y,x)
             th1 = acos(y)
             ph1 = atan2(z,-x)

             yat%vex(i,j,k) = epx(th,ph,vxcofs)
             yit%vex(i,j,k) = epx(th1,ph1,vxcofs)

             yat%vey(i,j,k) = epx(th,ph,vycofs)
             yit%vey(i,j,k) = epx(th1,ph1,vycofs)

             yat%vez(i,j,k) = epx(th,ph,vzcofs)
             yit%vez(i,j,k) = epx(th1,ph1,vzcofs)

             yat%den(i,j,k) = epx(th,ph,dencofs)
             yit%den(i,j,k) = epx(th1,ph1,dencofs)
          end do
       end do
       !call set_vars(vxcofs,vycofs,vzcofs,dencofs,modlya%xzn(i),dphidr(i,1,1))
       call calc_quads(qxx,qyy,qzz,qxy,qxz,qyz,vxcofs,vycofs,vzcofs,dencofs,modlya%xzn(i),dphidr(i,1,1))
       axx = axx + qxx*dr(i); ayy = ayy + qyy*dr(i); azz = azz + qzz*dr(i);
       axy = axy + qxy*dr(i); axz = axz + qxz*dr(i); ayz = ayz + qyz*dr(i);
       !amp2(1) = amp2(1) + qxx*dr(i); amp2(2) = amp2(2) + qyy*dr(i); amp2(3) = amp2(3) + qzz*dr(i);
       !amp2(4) = amp2(4) + qxy*dr(i); amp2(5) = amp2(5) + qxz*dr(i); amp2(6) = amp2(6) + qyz*dr(i);
    end do
    !$OMP END PARALLEL DO
    
    !yat%gpo = 0.0d0
    !yit%gpo = 0.0d0


    !CALL gw(yat,amplya,-1.0d0)
    !CALL gw(yit,amplyi,1.0d0)
    !write(*,*) yat%time-0.24892d0,amplya+amplyi
    amp1 = 0.0d0!amplya+amplyi

    amp2(1) = gc2vf * geofac * axx / c2
    amp2(2) = gc2vf * geofac * ayy / c2
    amp2(3) = gc2vf * geofac * azz / c2
    amp2(4) = gc2vf * geofac * axy / c2
    amp2(5) = gc2vf * geofac * axz / c2
    amp2(6) = gc2vf * geofac * ayz / c2
    write(*,*) amp2
    deALLOCATE (dth, STAT = ast)
    deALLOCATE (dph, STAT = ast)  
    deALLOCATE (sph, STAT = ast)
    deALLOCATE (cph, STAT = ast)
    deALLOCATE (cth, STAT = ast)
    deALLOCATE (sth, STAT = ast)
    
  end subroutine integral_test

  subroutine gw(modl,amp,yf)
    implicit none
    TYPE(fruit), INTENT(IN) :: modl
    REAL(KIND=8), DIMENSION(6), INTENT(OUT) :: amp 
    INTEGER :: nx,ny,nz,i,j,k,ast,ic
    REAL(KIND=8) :: geofac
    REAL(KIND=8),intent(in) :: yf
    parameter(geofac = 1.d0/3.d0)

    REAL(KIND=8) :: pc_cl
    parameter(pc_cl = 2.99792458d+10)

    REAL(KIND=8) :: pc_gc
    parameter(pc_gc = 6.67259d-08)

    REAL(KIND=8) :: pc_pi
    parameter(pc_pi = dacos(-1d0))

    REAL(KIND=8) ::  gc2vf,c2,A_xx,A_yy,A_zz,A_xy,A_yz,A_xz, &
         x,y,z,v_x,v_y,v_z,rsin, &
         dPdx, dPdy,DPdz,dmas,wint
    REAL(KIND=8), dimension(:,:,:),ALLOCATABLE :: dphidr(:,:,:),dphidth(:,:,:), & 
         dphidphi(:,:,:)
    REAL(KIND=8), dimension(:),ALLOCATABLE :: dph(:),dth(:),dr(:),cth,sth,cph,sph,axt,grav
    REAL(KIND=8) :: corr_sph,corr_cth,corr_sth
    gc2vf = pc_gc/pc_cl**2d0
    c2 = pc_cl**2d0

    nx=size(modl%den(:,1,1))
    ny=size(modl%den(1,:,1))
    nz=size(modl%den(1,1,:))
    !write(*,*) nx,ny,nz
    ALLOCATE (dth(ny), STAT = ast)
    ALLOCATE (dph(nz), STAT = ast)
    dth = dcos(modl%yzl(:))-dcos(modl%yzr(:))
    dph = modl%zzr(:)-modl%zzl(:)

    !ALLOCATE (corr_sph(nz), STAT = ast)
    !ALLOCATE (corr_cth(ny), STAT = ast)
    !ALLOCATE (corr_sth(ny), STAT = ast)
    !construct correction terms for sph, cth,sth
    ! corr_sph = SUM(dsin(modl%zzn(:))**2d0*dph(:))
    ! corr_cth = SUM(dcos(modl%yzn(:))**2d0*dth(:))
    ! corr_sth = SUM(dsin(modl%yzn(:))**2d0*dth(:))

    !corr_sph = 1.0d0!dsqrt(pc_pi/corr_sph)
    corr_cth = 0.99995140318460529d0! dsqrt(2d0/3d0/corr_cth)
    corr_sth = 1.000024301064834d0!dsqrt(4d0/3d0/corr_sth)
    corr_sph = 0.99999978633434816d0 !Ewalds factor

    !     corr_cth = 0.99995140318460529
    !     corr_sth = 1.000024301064834 

    !      corr_cth = 0.99995140318460529
    !      corr_sth = 1.000024301064834
    !      



    ALLOCATE (sph(nz), STAT = ast)
    ALLOCATE (cph(nz), STAT = ast)

    ALLOCATE (cth(ny), STAT = ast)
    ALLOCATE (sth(ny), STAT = ast)

    do j = 1,ny
       cth(j) = dcos(modl%yzn(j))!*corr_cth
       sth(j) = dsin(modl%yzn(j))!*corr_sth
    end do
    do k =1,nz
       cph(k) = dcos(modl%zzn(k))
       sph(k) = dsin(modl%zzn(k))!*corr_sph
    end do

    ALLOCATE (dphidr(nx,ny,nz), STAT = ast)
    ALLOCATE (dphidth(nx,ny,nz), STAT = ast)
    ALLOCATE (dphidphi(nx,ny,nz), STAT = ast)
    dphidth = 0.0d0
    dphidphi = 0.0d0

    do i=1,nx-1
       !write(*,*) i+1,nx,modl%gpo(i+1,ny,1)
       dphidr(i,:,:) = (modl%gpo(i+1,1:ny,:)-modl%gpo(i,1:ny,:))/(modl%xzr(i)-modl%xzl(i))
    enddo
    dphidr(nx,:,:) = (modl%gpo(nx,1:ny,:)-modl%gpo(nx-1,1:ny,:))/(modl%xzr(nx)-modl%xzl(nx))

    A_xx = 0d0
    A_yy = 0d0
    A_zz = 0d0
    A_xy = 0d0
    A_xz = 0d0
    A_yz = 0d0
    ALLOCATE (dr(nx), STAT = ast)
    ALLOCATE(axt(nx*ny*nz), STAT = ast)
    dr = modl%xzr(:)**3-modl%xzl(:)**3
    !dr = modl%xzn(:)**2 * (modl%xzr(:)-modl%xzl(:))
    ic =1
    !!cc!$OMP PARALLEL DO PRIVATE(i), REDUCTION(+:A_xx,A_yy,A_zz,A_xy,A_yz,A_xz)
    do k=1,nz
       do j=1,ny
          do i=100,nx

             if(yf .eq. -1.0d0) then
                rsin = modl%xzn(i) * sth(j)
                y = modl%xzn(i)*cth(j)
                x = -rsin * cph(k)
                z = rsin * sph(k)

                v_x = -((sth(j)*modl%vex(i,j,k)+cth(j) * & 
                     modl%vey(i,j,k))*cph(k)  - sph(k)*modl%vez(i,j,k))
                v_z = (sth(j)*modl%vex(i,j,k)+cth(j)* &
                     modl%vey(i,j,k))*sph(k) + cph(k)*modl%vez(i,j,k)
                v_y = cth(j)*modl%vex(i,j,k)-sth(j)* &
                     modl%vey(i,j,k)


                dPdx = -((sth(j)*dphidr(i,j,k) + cth(j)*dphidth(i,j,k) ) * &
                     cph(k) - sph(k)*dphidphi(i,j,k))
                dPdz = (sth(j)*dphidr(i,j,k) + cth(j)*dphidth(i,j,k) ) * &
                     sph(k) + cph(k)*dphidphi(i,j,k)
                dPdy = cth(j)*dphidr(i,j,k) - sth(j)*dphidth(i,j,k)
             else
                rsin = modl%xzn(i) * sth(j)
                z = modl%xzn(i)*cth(j)
                x = rsin * cph(k)
                y = rsin * sph(k)

                v_x = ( (sth(j)*modl%vex(i,j,k)+cth(j) * & 
                     modl%vey(i,j,k) )*cph(k)  - sph(k)*modl%vez(i,j,k))
                v_y = (sth(j)*modl%vex(i,j,k)+cth(j)* &
                     modl%vey(i,j,k))*sph(k) + cph(k)*modl%vez(i,j,k)
                v_z = cth(j)*modl%vex(i,j,k)-sth(j)* &
                     modl%vey(i,j,k)


                dPdx = ((sth(j)*dphidr(i,j,k) + cth(j)*dphidth(i,j,k) ) * &
                     cph(k) - sph(k)*dphidphi(i,j,k))
                dPdy = (sth(j)*dphidr(i,j,k) + cth(j)*dphidth(i,j,k) ) * &
                     sph(k) + cph(k)*dphidphi(i,j,k)
                dPdz = cth(j)*dphidr(i,j,k) - sth(j)*dphidth(i,j,k)

             end if

             dmas = modl%den(i,j,k)*dr(i)*dth(j)*dph(k)*modl%yyw(j,k)
             A_xx = A_xx + dmas * ( (v_x*v_x - x*dPdx) - 1d0/3d0*(v_x**2 + v_y**2 + v_z**2 - x*dPdx - y*dPdy - z*dPdz))
             A_yy = A_yy + dmas * ( (v_y*v_y - y*dPdy) - 1d0/3d0*(v_x**2 + v_y**2 + v_z**2 - x*dPdx - y*dPdy - z*dPdz))
             A_zz = A_zz + dmas * ( (v_z*v_z - z*dPdz) - 1d0/3d0*(v_x**2 + v_y**2 + v_z**2 - x*dPdx - y*dPdy - z*dPdz))
             A_xy = A_xy + dmas * (2d0*v_x*v_y - x*dPdy - y*dPdx)
             A_xz = A_xz + dmas * (2d0*v_x*v_z - x*dPdz - z*dPdx)
             A_yz = A_yz + dmas * (2d0*v_y*v_z - y*dPdz - z*dPdy)
          enddo
       enddo
    enddo
    !CALL heapsort(axt)
    A_xx = 2d0*geofac * A_xx
    A_yy = 2d0*geofac * A_yy
    A_zz = 2d0*geofac * A_zz

    A_xy = geofac * A_xy
    A_xz = geofac * A_xz
    A_yz = geofac * A_yz

    amp(1) = gc2vf * A_xx / c2
    amp(2) = gc2vf * A_yy / c2
    amp(3) = gc2vf * A_zz / c2
    amp(4) = gc2vf * A_xy / c2
    amp(5) = gc2vf * A_xz / c2
    amp(6) = gc2vf * A_yz / c2
    deALLOCATE (dth, STAT = ast)
    deALLOCATE (dph, STAT = ast)  
    deALLOCATE (sph, STAT = ast)
    deALLOCATE (cph, STAT = ast)
    deALLOCATE (cth, STAT = ast)
    deALLOCATE (sth, STAT = ast)
    deALLOCATE (dphidr, STAT = ast)
    deALLOCATE (dphidth, STAT = ast)
    deALLOCATE (dphidphi, STAT = ast)
    deALLOCATE (dr, STAT = ast)
    deALLOCATE(axt, STAT = ast)
  end subroutine gw


  function epx(ph,th,cfs) result(out)
    USE sph_leg_pol
    implicit none
    integer l,m,ast
    real(kind=8),intent(in) :: cfs(:,:)
    real(kind=8) :: cof(0:lmax,-lmax:lmax)
    real(kind=8) :: spa,ph,th,out
    !l = 20!size(cfs(:,1))
    !ALLOCATE(cof(0:lmax,-lmax:lmax), STAT = ast)
    cof = cfs
    out = 0.0d0
    do l = 0,lmax!size(cfs(:,1))
       do m = -l,l
          out = out + (spharm_r(l,m,th,ph))*cof(l,m)
       end do
    end do
  end function epx











end module sphexp
