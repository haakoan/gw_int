module tblinf
  use data_types
  real(kind=8), allocatable, public :: ts1(:),ts2(:),ts3(:),ts4(:),ts5(:),ts6(:),ts7(:),ts8(:),ts9(:)
  real(kind=8), allocatable, public :: ts10(:),ts11(:),ts12(:),ts13(:),ts14(:),ts15(:),ts16(:)

  interface
     function lookforkey_c(l1,m1,l2,m2,l3,m3,n1,n2,n3,n4) bind(C, name="lookforkey_")
       use iso_c_binding, only : c_double, c_int
       implicit none
       real(kind=c_double) :: lookforkey_c
       integer :: l1,m1,l2,m2,l3,m3,n1,n2,n3,n4
     end function lookforkey_c

     subroutine set_tbl_c() bind(C, name="set_tbl_")
       !Nothing her but an interface
     end subroutine set_tbl_c
  end interface

contains
  function ILU(l1,m1,l2,m2,l3,m3,n1,n2,n3,n4)
    use iso_c_binding, only : c_double, c_int
    implicit none
    real(kind=c_double) :: ILU
    integer, intent(in) :: l1,m1,l2,m2,l3,m3,n1,n2,n3,n4
    integer:: s1,q1,s2,q2,s3,q3   
    logical :: lps
    integer:: lm1(2,3),lm2(2),i,j
    ILU = 0.0d0
    if( MODULO((m1+m2+m3+l1+l2+l3+n1),2) .eq. 0) then

       lm1(1,1) = l1 ; lm1(2,1) = m1 ; lm1(1,2) = l2 ; lm1(2,2) = m2 ; lm1(1,3) = l3 ; lm1(2,3) = m3
       lps = .TRUE.
       j = 1
       do while (lps)
          if(lm1(1,j) .gt. lm1(1,j+1)) then
             lm2 = lm1(:,j)
             lm1(:,j) = lm1(:,j+1)
             lm1(:,j+1) = lm2
             j = 1
          end if
          j = j+1
          if(j .gt. 2) then
             lps = .FALSE.
          end if
       end do
       lps = .TRUE.
       j = 1
       do while (lps)
          if(lm1(1,j) .eq. lm1(1,j+1)) then
             if(lm1(2,j) .gt. lm1(2,j+1)) then
                lm2 = lm1(:,j)
                lm1(:,j) = lm1(:,j+1)
                lm1(:,j+1) = lm2
                j = 1
             end if
          end if
          j = j+1
          if(j .gt. 2) then
             lps = .FALSE.
          end if
       end do
        s1 =  lm1(1,1) ; q1= lm1(2,1); s2 = lm1(1,2); q2= lm1(2,2); s3= lm1(1,3); q3= lm1(2,3)
        !write(*,*) s1,q1,s2,q2,s3,q3
       if((n3 .eq. 0 .and. n4 .eq. 2) .and. ((q1+q2+q3 .eq. -2) .or. (q1+q2+q3 .eq. 2) .or. (q1+q2+q3 .eq. 0) )) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       elseif((n3 .eq. 0 .and. n4 .eq. 0) .and. (q1+q2+q3 .eq. 0) )) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       elseif((n3 .eq. 0 .and. n4 .eq. 1) .and. ((q1+q2+q3 .eq. 1) .or. (q1+q2+q3 .eq. -1))) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       elseif((n3 .eq. 2 .and. n4 .eq. 0) .and. ((q1+q2+q3 .eq. -2) .or. (q1+q2+q3 .eq. 2) .or. (q1+q2+q3 .eq. 0) )) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       elseif((n3 .eq. 2 .and. n4 .eq. 1) .and. &
         ((q1+q2+q3 .eq. 1) .or. (q1+q2+q3 .eq. -1) .or. (q1+q2+q3 .eq. 3) .or. (q1+q2+q3 .eq. -3))) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       elseif((n3 .eq. 2 .and. n4 .eq. 2) .and. ((q1+q2+q3 .eq. -4) .or. (q1+q2+q3 .eq. 4) .or. (q1+q2+q3 .eq. 0) )) then
          ILU= lookforkey_c(s1,q1,s2,q2,s3,q3,n1,n2,n3,n4)
       end if
    end if
  end function ILU

  subroutine set_tbl()
    call set_tbl_c()
  end subroutine set_tbl

  function incr(l1,m1,l2,m2,l3,m3,n1,n2,n3,n4,i)
    integer, intent(in) :: l1,m1,l2,m2,l3,m3,n1,n2,n3,n4
    integer:: i,j,incr
    j = i
    if( MODULO((m1+m2+m3+l1+l2+l3+n1),2) .eq. 0) then
       if((n3 .eq. 0 .and. n4 .eq. 2) .and. ((m1+m2+m3 .eq. -2) .or. (m1+m2+m3 .eq. 2) .or. (m1+m2+m3 .eq. 0) )) then
          j=i+1
       elseif((n3 .eq. 0 .and. n4 .eq. 1) .and. ((m1+m2+m3 .eq. 1) .or. (m1+m2+m3 .eq. -1))) then
          j=i+1
       elseif((n3 .eq. 0 .and. n4 .eq. 0) .and. (q1+q2+q3 .eq. 0) )) then
          j=i+1	
       elseif((n3 .eq. 2 .and. n4 .eq. 0) .and. ((m1+m2+m3 .eq. -2) .or. (m1+m2+m3 .eq. 2) .or. (m1+m2+m3 .eq. 0) )) then
          j=i+1
       elseif((n3 .eq. 2 .and. n4 .eq. 1) .and. &
         ((m1+m2+m3 .eq. 1) .or. (m1+m2+m3 .eq. -1) .or. (m1+m2+m3 .eq. 3) .or. (m1+m2+m3 .eq. -3))) then
          j=i+1
       elseif((n3 .eq. 2 .and. n4 .eq. 2) .and. ((m1+m2+m3 .eq. -4) .or. (m1+m2+m3 .eq. 4)  .or. (m1+m2+m3 .eq. 0))) then
          j=i+1
       end if
    end if
    incr = j
  end function incr

  subroutine set_arrys()
    implicit none
    real(kind=8), allocatable :: ys1(:)
    integer :: i4
    integer :: ast,arl
    arl = ((lmax+1)*(2*lmax+1))**3

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 0, 2, 0, 0)
    ALLOCATE (ts1(i4), STAT = ast)
    ts1 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)
   
    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 0, 2, 0, 2)
    ALLOCATE (ts2(i4), STAT = ast)
    ts2 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 0, 2, 2, 0)
    ALLOCATE (ts3(i4), STAT = ast)
    ts3 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 1, 1, 0, 0)
    ALLOCATE (ts4(i4), STAT = ast)
    ts4 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 1, 1, 0, 2)
    ALLOCATE (ts5(i4), STAT = ast)
    ts5 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 1, 1, 2, 0)
    ALLOCATE (ts6(i4), STAT = ast)
    ts6 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 2, 0, 0, 0)
    ALLOCATE (ts7(i4), STAT = ast)
    ts7 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)
     
    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 2, 0, 0, 2)
    ALLOCATE (ts8(i4), STAT = ast)
    ts8 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 2, 0, 2, 0)
    ALLOCATE (ts9(i4), STAT = ast)
    ts9 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)
  
    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 0, 2, 0, 1)
    ALLOCATE (ts10(i4), STAT = ast)
    ts10 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 1, 1, 0, 1)
    ALLOCATE (ts11(i4), STAT = ast)
    ts11 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array(ys1,i4, 2, 0, 0, 1)
    ALLOCATE (ts12(i4), STAT = ast)
    ts12 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array1(ys1,i4, 1, 1, 2, 0)
    ALLOCATE (ts13(i4), STAT = ast)
    ts13 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array1(ys1,i4, 2, 0, 0, 2)
    ALLOCATE (ts14(i4), STAT = ast)
    ts14 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)

    ! ALLOCATE (ys1(arl), STAT = ast)
    ! call set_array1(ys1,i4, 0, 2, 0, 0)
    ! ALLOCATE (ts15(i4), STAT = ast)
    ! ts15 = ys1(1:i4)
    ! deALLOCATE (ys1, STAT = ast)

    ALLOCATE (ys1(arl), STAT = ast)
    call set_array1(ys1,i4, 1, 1, 0, 1)
    ALLOCATE (ts16(i4), STAT = ast)
    ts16 = ys1(1:i4)
    deALLOCATE (ys1, STAT = ast)


  end subroutine set_arrys


  
  subroutine set_array(arry,i3,n1,n2,n3,n4)
    implicit none
    integer,intent(in) :: n1,n2,n3,n4
    real(kind=8),intent(inout) :: arry(:)
    integer :: arl,ast
    integer :: l1,m1,l2,m2,l3,m3,i1,i2
    integer, intent(out) :: i3
    !arl = ((lmax+1)*(2*lmax+1))**3
    !ALLOCATE (arry(arl), STAT = ast)
    i1 = 0 ; i2 = 0
    do l1 = 0,lmax
       do m1 = -l1,l1
          do l2 = 0,lmax
             do m2 = -l2,l2
                do l3 = 0,lmax
                   do m3 = -l3,l3
                      i2 = incr(l1,m1,l2,m2,l3,m3,n1,n2,n3,n4,i1)
                      if(i2 .gt. i1) then
                         i1 = i2
                         arry(i1) = ILU(l1, m1, l2, m2, l3, m3, n1, n2, n3, n4)
                      end if
                   end do
                end do
             end do
          end do
       end do
    end do
    i3 = i1
  end subroutine set_array

  subroutine set_array1(arry,i3,n1,n2,n3,n4)
    implicit none
    integer,intent(in) :: n1,n2,n3,n4
    real(kind=8),intent(inout) :: arry(:)
    integer :: arl,ast
    integer :: l1,m1,i1,i2
    integer, intent(out) :: i3
    !arl = ((lmax+1)*(2*lmax+1))**3
    !ALLOCATE (arry(arl), STAT = ast)
    i1 = 0 ; i2 = 0
    do l1 = 0,lmax
       do m1 = -l1,l1
          i2 = incr(l1,m1,0,0,0,0,n1,n2,n3,n4,i1)
          if(i2 .gt. i1) then
             i1 = i2
             arry(i1) = ILU(l1, m1, 0, 0, 0, 0, n1, n2, n3, n4)
             !write(*,*) "lol", i1
          end if
         end do
    end do
    i3 = i1
  end subroutine set_array1
 
  

    
    ! tmp2 = ILU(l1, m1, 0, 0, 0, 0, 1, 1, 2, 0)
    ! tmp3 = ILU(l1, m1, 0, 0, 0, 0, 2, 0, 0, 2)
    ! tmp15 = ILU(l1, m1, 0, 0, 0, 0, 0, 2, 0, 0)
    ! tmp18 = ILU(l1, m2, 0, 0, 0, 0, 1, 1, 0, 1)



    ! !tmp4 = ILU(ys1,i4,l1, m1, l2, m2, l3, m3, 0, 2, 0, 0)
    ! !tmp5 = ILU(l1, m1, l2, m2, l3, m3, 0, 2, 0, 2)
    ! !tmp6 = ILU(l1, m1, l2, m2, l3, m3, 0, 2, 2, 0)
    ! !tmp7 = ILU(l1, m1, l2, m2, l3, m3, 1, 1, 0, 0)
    ! ! tmp8 = ILU(l1, m1, l2, m2, l3, m3, 1, 1, 0, 2)
    ! ! tmp10 = ILU(l1, m1, l2, m2, l3, m3, 1, 1, 2, 0)
    ! ! tmp11 = ILU(l1, m1, l2, m2, l3, m3, 2, 0, 0, 0)
    ! ! tmp12 = ILU(l1, m1, l2, m2, l3, m3, 2, 0, 0, 2)
    ! ! tmp14 = ILU(l1, m1, l2, m2, l3, m3, 2, 0, 2, 0)
    ! ! tmp19 = ILU(l1, m1, l2, m2, l3, m3, 0, 2, 0, 1)
    ! ! tmp20 = ILU(l1, m1, l2, m2, l3, m3, 1, 1, 0, 1)
    ! ! tmp22 = ILU(l1, m1, l2, m2, l3, m3, 2, 0, 0, 1)
    
  

    



       




               


  
end module tblinf
